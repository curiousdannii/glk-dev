Constant Story "AutoSave";
Constant Headline "^Not a game.^";

Release 1;

! Unit test for interpreter autosave.

Include "Parser";
Include "VerbLib";

Global totalfailures;
Global errorcount;

[ Initialise;
	location = Kitchen;
	StartDaemon(Kitchen);
];

Object Kitchen "Autosave Room"
  with
	description [;
		print "A voice booooms out: Welcome to the test chamber.^^";
		print "This test is a little bit weird. Type ~run test~ (or
			~run all~). Each test will pause in the middle with a
			~Kill and hit a key>~ prompt. (Or, for some tests,
			~Kill and enter a line>~.)
			At that point, kill the interpreter and then restart it --
			hopefully reloading to that point.
			Hit a key (or line of text) to continue the test.^";
	],
	daemon [;
		if (totalfailures) {
			print "Total failures: ", totalfailures, "^";
			totalfailures = 0;
		}
	],
  has light;

[ RunTestSub;
	if (~~(noun ofclass TestObj))
		"That's not a test.";
	print "Running ", (the) noun, ".^";

	errorcount = 0;
	
	noun.testfunc();

	totalfailures = totalfailures + errorcount;

	if (errorcount)
		print "^FAILED: Total errors: ", errorcount, ".^";
	else
		print "^Passed.^";
	new_line;
];

[ WaitKey res;
	print "^Kill and hit a key>";
	
	glk($00D2, gg_mainwin); ! request_char_event
	while (true) {
		glk($00C0, gg_event); ! select
		if (gg_event-->0 == 2 && gg_event-->1 == gg_mainwin) {
			res = gg_event-->2;
			break;
		}
	}

	print "...", (charname) res, ".^";
];

[ WaitKeySilent res;
	glk($00D2, gg_mainwin); ! request_char_event
	while (true) {
		glk($00C0, gg_event); ! select
		if (gg_event-->0 == 2 && gg_event-->1 == gg_mainwin) {
			res = gg_event-->2;
			break;
		}
	}
	return res;
];

[ charname ch;
	if (ch < 0) {
		SpecialKeyName(ch);
		return;
	}
	if (ch == 32) {
		print "<space>";
		return;
	}
	if (ch < 32) {
		print "<ctrl-", (char) (ch+64), ">";
		return;
	}
	if (ch <= 126) {
		print "'", (char) ch, "'";
		return;
	}
	print "<???>";
];

[ SpecialKeyName res;
	print "<";
	switch (res) {
		$ffffffff: print "unknown";
		$fffffffe: print "left";
		$fffffffd: print "right";
		$fffffffc: print "up";
		$fffffffb: print "down";
		$fffffffa: print "return";
		$fffffff9: print "delete";
		$fffffff8: print "escape";
		$fffffff7: print "tab";
		$fffffff6: print "page-up";
		$fffffff5: print "page-down";
		$fffffff4: print "home";
		$fffffff3: print "end";
		$ffffffef: print "f1";
		$ffffffee: print "f2";
		$ffffffed: print "f3";
		$ffffffec: print "f4";
		$ffffffeb: print "f5";
		$ffffffea: print "f6";
		$ffffffe9: print "f7";
		$ffffffe8: print "f8";
		$ffffffe7: print "f9";
		$ffffffe6: print "f10";
		$ffffffe5: print "f11";
		$ffffffe4: print "f12";
		default: print "???";
	}
	print ">";
];
	
[ check val wanted;
	if (val == wanted) {
		print val;
		rtrue;
	}
	errorcount++;
	print val, " (should be ", wanted, " FAIL)";
	rfalse;
];

[ check_bytelist _vararg_count    arr ix wanted val;
	@copy sp arr;
	_vararg_count--;
	
	for (ix=0 : ix<_vararg_count : ix++) {
		@copy sp wanted;
		if (ix)
			print ", ";
		@aloadb arr ix val;
		if (wanted == val) {
			print wanted;
		}
		else {
			errorcount++;
			print val, " (should be ", wanted, " FAIL)";
		}
	}
];

[ check_str str buf len  newlen ix good ch;
	good = true;
	newlen = string_to_array(str, cbuffer2, BUFFER_SIZE);
	if (newlen ~= len) {
		good = false;
	}
	else {
		for (ix=0 : ix<len : ix++) {
			if (buf->ix ~= cbuffer2->ix)
				good = false;
		}
	}
	print "~";
	for (ix=0 : ix<len : ix++) {
		ch = buf->ix;
		@streamchar ch;
	}
	print "~ len ", len;
	if (~~good) {
		errorcount++;
		print " (should be ~";
		for (ix=0 : ix<newlen : ix++) {
			ch = cbuffer2->ix;
			@streamchar ch;
		}
		print "~ len ", newlen, ", FAIL)";
	}
];

[ string_to_array val arr arrlen    str oldstr len;
	oldstr = glk($0048); ! stream_get_current
	str = glk($0043, arr, arrlen, 1, 0); ! stream_open_memory
	if (str == 0) return 0;

	glk($0047, str); ! stream_set_current

	if (val->0 == $c0 or $c1)
		val();
	else
		@streamstr val;

	glk($0047, oldstr); ! stream_set_current
	@copy $ffffffff sp;
	@copy str sp;
	@glk $0044 2 0; ! stream_close
	@copy sp len;
	@copy sp 0;

	return len;
];

Class TestObj
  with name 'test' 'tests//p',
	before [;
		Enter: <<RunTest self>>;
		Take: <<RunTest self>>;
		Examine:
			"This tests ", (string) self.testdesc, ".";
	],
	testdesc 0,
	testfunc 0,
  has static;

Global glob;
Global glob2;
Constant BUFFER_SIZE 256;
Array cbuffer  -> BUFFER_SIZE;
Array cbuffer2 -> BUFFER_SIZE;
Array ubuffer --> BUFFER_SIZE;

TestObj -> Base "base test"
  with
	name 'base' 'basic',
	testdesc "basic autosave functionality",
	testfunc [ loc;
		loc = 97;
		glob = 86;
		@push 123;
		WaitKey();
		@pull glob2;
		print "*sp="; check(glob2, 123); print "; ";
		print "loc="; check(loc, 97); print "; ";
		print "glob="; check(glob, 86); print "^";
	];

TestObj -> Randomize "random test"
  with
	name 'random' 'randomize',
	testdesc "random number generator",
	testfunc [ ix val;
		print "Deterministic...^";
		@setrandom 1;
		for (ix=0 : ix<16 : ix++) {
			@random 0 val;
			ubuffer-->ix = val;
		}

		WaitKey();

		print "Array:";
		@setrandom 1;
		for (ix=0 : ix<16 : ix++) {
			@random 0 val;
			print " ", ix, "="; check(val, ubuffer-->ix);
			ubuffer-->ix = val;
		}
		new_line;
		
		print "Nondeterministic...^";

		WaitKey();

		print "Array:";
		@setrandom 0;
		for (ix=0 : ix<16 : ix++) {
			@random 0 val;
			print " ", ix, "!=";
			if (val ~= ubuffer-->ix) {
				print val;
			}
			else {
				errorcount++;
				print val, " (should NOT be ", ubuffer-->ix, " FAIL)";
			}
			ubuffer-->ix = val;
		}
		new_line;
	];

TestObj -> IoSys "iosys test"
  with
	name 'iosys',
	testdesc "iosys test",
	testfunc [ len res;
		print "iosys 0:^";
		print "^Kill and hit a key>";
		@setiosys 0 0;
		res = WaitKeySilent();
		len = string_to_array("static null", cbuffer, BUFFER_SIZE);
		@setiosys 2 0;
		print "...", (charname) res, ".^";
		check_str("", cbuffer, len); print "^";
		new_line;

		print "iosys 1 array:^";
		print "^Kill and hit a key>";
		glob = 0;
		@setiosys 1 parenthesize_array;
		res = WaitKeySilent();
		print "Parens.^";
		len = 24;
		@setiosys 2 0;
		print "...", (charname) res, ".^";
		check_str("(P)(a)(r)(e)(n)(s)(.)(^)", cbuffer, len); print "^";
		new_line;

		print "iosys 1 stream:^";
		print "^Kill and hit a key>";
		glob = 0;
		@setiosys 1 bracketize_stream;
		res = WaitKeySilent();
		len = string_to_array("Bra-cket.", cbuffer, BUFFER_SIZE);
		@setiosys 2 0;
		print "...", (charname) res, ".^";
		check_str("<B><r><a><-><c><k><e><t><.>", cbuffer, len); print "^";
		new_line;
		];

[ parenthesize_array ch;
	cbuffer->glob = '(';
	glob++;
	cbuffer->glob = ch;
	glob++;
	cbuffer->glob = ')';
	glob++;
];
		
[ bracketize_stream ch;
	glk($0080, '<'); ! put_char
	glk($0080, ch); ! put_char
	glk($0080, '>'); ! put_char
];

TestObj -> Protect "protect test"
  with
	name 'protect',
	testdesc "memory-range protect test",
	testfunc [ val addr ix;
		@gestalt 3 0 val; ! Undo
		if (~~val)
			print "Interpreter claims to not support undo. (Continuing test anyway...)^^";

		addr = cbuffer+3;
		@protect addr 6;
		for (ix=0 : ix<15 : ix++)
			cbuffer->ix = ix+1;
		WaitKey();
		cbuffer->15 = 20;
		@saveundo val;
		if (val == 1) {
			print "@@64saveundo failed!^";
			errorcount++;
			return;
		}
		if (val == 0) {
			print "Undo saved...^";
			! The following changes will be undone.
			for (ix=0 : ix<16 : ix++)
				cbuffer->ix = 99;
			errorcount++;
			print "Restoring undo...^";
			@restoreundo val;
			if (val == 1) {
				print "@@64restoreundo failed (value 1)!^";
			}
			else {
				print "@@64restoreundo failed with unknown return value: ", val, "^";
			}
			errorcount++;
			return;
		}
		else if (val ~= -1) {
			print "Unknown @@64saveundo return value: ", val, "^";
			errorcount++;
			return;
		}
		print "Undo succeeded, return value "; check(val, -1); print ".^";
		
		print "Protected 3,6: ";
		check_bytelist(cbuffer, 1,2,3,99,99,99,99,99,99,10,11,12,13,14,15,20); print "^";

		@protect 0 0;
	];

! ### all the various @glk operand modes
! ### timer input
! ### line input
! ### line input with funny terminator and echo flags
! ### an open file stream (read and write)
! ### an open memory stream (read and write)
! ### window stream writecounts
! ### an open transcript file
! ### the heap
! ### accelerated funcs

Include "Grammar";

Extend only 'run' replace
	* multi -> RunTest;

